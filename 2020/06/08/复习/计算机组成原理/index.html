<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="sweet8bit">
  <meta name="keywords" content="">
  <title>计算机组成原理 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sweet</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/pageBackground1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-08 15:10">
      2020年6月8日 下午
    </time>
  </div>


<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>关于计算机组成原理的一些复习总结<br>(等待补充)</p>
<h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><h3 id="计算机系统软硬件的感念"><a href="#计算机系统软硬件的感念" class="headerlink" title="计算机系统软硬件的感念"></a>计算机系统软硬件的感念</h3><h4 id="计算机系统由硬件系统和软件系统组成"><a href="#计算机系统由硬件系统和软件系统组成" class="headerlink" title="计算机系统由硬件系统和软件系统组成"></a>计算机系统由硬件系统和软件系统组成</h4><pre><code>硬件： 看得见，摸得着的电子元器件
软件： 看不见，摸不着的程序和数据组成的文档
    ·软件的发展可以充分发挥计算机硬件的功能，提高计算机的工作效率。
    ·软件性能的发挥必须依托硬件，计算机的性能的好坏取决于软、硬件功能的总和</code></pre><h4 id="软件系统：系统软件和应用程序"><a href="#软件系统：系统软件和应用程序" class="headerlink" title="软件系统：系统软件和应用程序"></a>软件系统：系统软件和应用程序</h4><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><h4 id="上机解题的过程"><a href="#上机解题的过程" class="headerlink" title="上机解题的过程"></a>上机解题的过程</h4><pre><code>源程序  机器语言</code></pre><h4 id="计算机系统的层次结构-1"><a href="#计算机系统的层次结构-1" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h4><pre><code>高级语言  虚拟机
汇编语言  虚拟机
操作系统  虚拟机
机器语言  实体机
为程序语言  实体机
操作系统的作用：1.为高级语言和汇编语言提供一些基本操作
              2.管理计算机的软、硬件资源
              3.方便人去操作计算机</code></pre><h3 id="计算机系统组成和计算机体系结构"><a href="#计算机系统组成和计算机体系结构" class="headerlink" title="计算机系统组成和计算机体系结构"></a>计算机系统组成和计算机体系结构</h3><h4 id="计算机体系结构：能被计算机程序员看到的计算机系统的属性"><a href="#计算机体系结构：能被计算机程序员看到的计算机系统的属性" class="headerlink" title="计算机体系结构：能被计算机程序员看到的计算机系统的属性"></a>计算机体系结构：能被计算机程序员看到的计算机系统的属性</h4><pre><code>例：指令集     数据类型    寻址方式等等</code></pre><h4 id="计算机系统组成：如何实现计算机体系结构中所体现的属性"><a href="#计算机系统组成：如何实现计算机体系结构中所体现的属性" class="headerlink" title="计算机系统组成：如何实现计算机体系结构中所体现的属性"></a>计算机系统组成：如何实现计算机体系结构中所体现的属性</h4><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><h3 id="冯-诺依曼计算机的特点"><a href="#冯-诺依曼计算机的特点" class="headerlink" title="冯.诺依曼计算机的特点"></a>冯.诺依曼计算机的特点</h3><h4 id="1946-美国宾夕法尼亚大学-ENIAC"><a href="#1946-美国宾夕法尼亚大学-ENIAC" class="headerlink" title="1946  美国宾夕法尼亚大学  ENIAC"></a>1946  美国宾夕法尼亚大学  ENIAC</h4><h4 id="冯-诺依曼-EDVAC-“存储程序”-1945"><a href="#冯-诺依曼-EDVAC-“存储程序”-1945" class="headerlink" title="冯.诺依曼  EDVAC  “存储程序”  1945"></a>冯.诺依曼  EDVAC  “存储程序”  1945</h4><h4 id="冯-诺依曼计算机的特征-图灵-模仿游戏"><a href="#冯-诺依曼计算机的特征-图灵-模仿游戏" class="headerlink" title="冯.诺依曼计算机的特征    图灵  模仿游戏"></a>冯.诺依曼计算机的特征    图灵  模仿游戏</h4><pre><code>·计算机由运算器、控制器、存储器、输入设备、输出设备五部分组成
·指令和数据是以同等地位存放于存储器内，并可按地址寻址
·指令和数据均用二进制数表示
·指令由操作码和地址码组成的，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置
·指令在存储器中按顺序存放的
·运算器为中心</code></pre><h3 id="计算机硬件框图"><a href="#计算机硬件框图" class="headerlink" title="计算机硬件框图"></a>计算机硬件框图</h3><h4 id="冯-诺依曼计算机结构框图"><a href="#冯-诺依曼计算机结构框图" class="headerlink" title="冯.诺依曼计算机结构框图"></a>冯.诺依曼计算机结构框图</h4><h4 id="现代计算机结构框图"><a href="#现代计算机结构框图" class="headerlink" title="现代计算机结构框图"></a>现代计算机结构框图</h4><h4 id="各部件的功能"><a href="#各部件的功能" class="headerlink" title="各部件的功能"></a>各部件的功能</h4><pre><code>·运算器：用来完成算术运算和逻辑运算，并将结果存储在存储器中
·控制器：用来控制、指挥程序和数据的输入、运算及处理结果
·存储器：用来存放程序和数据
·输入设备：将人们熟悉的信息形式转换成计算机能识别的信息形式
·输出设备：将计算机能识别的信息形式转换成人们熟悉的信息形式</code></pre><h4 id="运算器和控制器统称为CPU-Central-Processing-Unit-（中央处理器-中央处理单元-微处理器）"><a href="#运算器和控制器统称为CPU-Central-Processing-Unit-（中央处理器-中央处理单元-微处理器）" class="headerlink" title="运算器和控制器统称为CPU(Central Processing Unit)（中央处理器/中央处理单元/微处理器）"></a>运算器和控制器统称为CPU(Central Processing Unit)（中央处理器/中央处理单元/微处理器）</h4><h4 id="输入设备和输出设备简称I-O（Input-Output-Equipment）设备"><a href="#输入设备和输出设备简称I-O（Input-Output-Equipment）设备" class="headerlink" title="输入设备和输出设备简称I/O（Input/Output Equipment）设备"></a>输入设备和输出设备简称I/O（Input/Output Equipment）设备</h4><h4 id="现代计算机可以由三部分组成：CPU、I-O、存储器（内存"><a href="#现代计算机可以由三部分组成：CPU、I-O、存储器（内存" class="headerlink" title="现代计算机可以由三部分组成：CPU、I/O、存储器（内存"></a>现代计算机可以由三部分组成：CPU、I/O、存储器（内存</h4><h3 id="计算机的工作步骤"><a href="#计算机的工作步骤" class="headerlink" title="计算机的工作步骤"></a>计算机的工作步骤</h3><h4 id="建立数学模型"><a href="#建立数学模型" class="headerlink" title="建立数学模型"></a>建立数学模型</h4><h4 id="确定计算方法"><a href="#确定计算方法" class="headerlink" title="确定计算方法"></a>确定计算方法</h4><h4 id="编制解题程序"><a href="#编制解题程序" class="headerlink" title="编制解题程序"></a>编制解题程序</h4><h2 id="计算机的-指令-工作过程"><a href="#计算机的-指令-工作过程" class="headerlink" title="计算机的(指令)工作过程"></a>计算机的(指令)工作过程</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><pre><code>存储单元
存储单元的地址
存储元件（存储基元/存储元）
存储字
存储字长
MAR（存储器地址寄存器）：用来存放欲访问的存储单元地址的
             其位数与存储单元的个数有关
MDR(存储器数据寄存器)：用来存放从存储器中取出的数据
                     用来将数据存储到存储器中的数据
               其位数与存储单元的字长有关</code></pre><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><pre><code>ACC:累加器
         ACC=ACC+X      ACC=ACC-X
MQ:乘商寄存器
X：用来操作数</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>功能：完成一条指令的操作过程：取指令，分析指令，执行指令</p>
<pre><code>PC（程序计数器）：用来存放欲执行的指令地址（用来存放下一条指令的地址的）
IR（指令寄存器）：用来存放当前正在执行的指令
CU（控制单元）：用来分析当前指令所需要完成的操作</code></pre><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><pre><code>接口</code></pre><h2 id="计算机的-硬件-主要技术指标"><a href="#计算机的-硬件-主要技术指标" class="headerlink" title="计算机的(硬件)主要技术指标"></a>计算机的(硬件)主要技术指标</h2><h3 id="机器字长：指CPU一次能处理的二进制数据的位数"><a href="#机器字长：指CPU一次能处理的二进制数据的位数" class="headerlink" title="机器字长：指CPU一次能处理的二进制数据的位数"></a>机器字长：指CPU一次能处理的二进制数据的位数</h3><h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><pre><code>最小单位：比特（位）(bit)
基本单位：字节（Byte)
           1B=8bit
               换算关系
       1TB=1024GB
       1GB=1024MB
       1MB=1024KB
       1KB=1024B
        1B=8bit</code></pre><h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><pre><code>频率：单位时间内变化次数
                  单位：Hz   KHz     MHz    GHz

主频：时钟（clock)工作频率

运算速度：单位时间内执行指令(加、减，乘，除）平均条数   单位：百万条指令/s   MIPS

CPI（Cycle Per Instruction）：执行一条指令需要多少个时钟周期

FLOPS:每秒钟可以执行多少个浮点数运算</code></pre><h2 id="计算机的发展应用"><a href="#计算机的发展应用" class="headerlink" title="计算机的发展应用"></a>计算机的发展应用</h2><h3 id="计算机的发展史"><a href="#计算机的发展史" class="headerlink" title="计算机的发展史"></a>计算机的发展史</h3><pre><code>   四个阶段：按照电子元器件
第一代：电子管
第二代：晶体管
第三代：中小规模集成电路
第四代：大规模超大规模集成电路   代表：CPU
第五代：？</code></pre><h3 id="微型计算机的出现和发展"><a href="#微型计算机的出现和发展" class="headerlink" title="微型计算机的出现和发展"></a>微型计算机的出现和发展</h3><pre><code>处理器芯片：4   8   16   32  64
存储器芯片容量：1K位   4K位    。。。。。    
4004   8008   8086   80286   80386   80486  。。。。
价格和速度
摩尔定律：每18个月翻一番
速度不匹配的问题
         @CPU和主存之间：CACHE
         @CPU和I/O：缓冲区</code></pre><h3 id="软件技术的兴起和发展"><a href="#软件技术的兴起和发展" class="headerlink" title="软件技术的兴起和发展"></a>软件技术的兴起和发展</h3><pre><code>面向机器语言（机器语言  汇编语言）
面向问题(过程）语言（C语言）
面向对象语言（C++   JAVA)
软件工程</code></pre><h3 id="计算机的应用"><a href="#计算机的应用" class="headerlink" title="计算机的应用"></a>计算机的应用</h3><pre><code>科学计算和数据处理
工业控制和实时控制
网络技术的应用
虚拟现实（VR）
办公自动化
CAD/CAM/CAE
多媒体技术
人工智能   python</code></pre><h3 id="计算机的展望"><a href="#计算机的展望" class="headerlink" title="计算机的展望"></a>计算机的展望</h3><p>##总线的概念以及分类</p>
<h3 id="总线的概念"><a href="#总线的概念" class="headerlink" title="总线的概念"></a>总线的概念</h3><pre><code>五大部件之间的互联方式
    分散连接：各部件之间使用单独的连线
         例：以运算器为中心硬件框图
                以存储器为中心硬件框图
    总线连接：各部件连到一组公共信息的传输线上（各部件共享传输介质）
总线数据传输方式
    并行传输
    串行传输
 总线的架构方式
     以CPU为中心的双总线结构
     以存储器为中心的双总线结构
     单总线结构：CPU、内存、I/O设备都挂到一根传输线上</code></pre><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><pre><code>片内总线：芯片内部的总线
    例：在CPU内部，寄存器与寄存器之间，寄存器与算术逻辑单元之间
系统总线（板极主线）：CPU、内存、I/O设备各大部件之间的信息传输线
    数据总线：用来传输各部件之间的数据信息
         其位数和机器字长、存储字长有关
    地址总线：指出传输数据的源地址和目的地址及I/O设备的接口（地址）
          其位数和存储单元的个数有关
    @控制总线：用来发出各种控制信号的传输线
            中断响应
            中断请求
            时钟
            复位
            存储器读/写
            I/O设备读/写
  通信总线：计算机系统之间或计算机系统与其它系统之间的通信传输线
      并行传输：速度快，适合于近距离传输数据（30m以内）
      串行传输：速度慢，适合于远距离传输数据</code></pre><h2 id="总线性能的指标及总线控制"><a href="#总线性能的指标及总线控制" class="headerlink" title="总线性能的指标及总线控制"></a>总线性能的指标及总线控制</h2><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><pre><code>总线的宽度：指数据总线的根数，单位bit(位）表示
   例：8位   16位   32位   64位
总线带宽：总线的数据传输速率，即单位时间内总线上传输数据的位数，单位MBps
   例：总线工作频率33MHz,总线宽度为32位，则总线带宽为多少？
           答：33MHz*4B=132MB/s
时钟同步/异步
   同步总线：总线上的数据与时钟同步工作的总线
   异步总线：总线上的数据不与时钟同不工作的总线
总线复用：一条信号线上分时传送两种信号
   例：地址总线和数据总线
 信号线数：地址总线、数据总线、控制总线三种总线数总和
 总线控制方式：突发工作、自动配置、仲裁方式、逻辑方式、计数方法等</code></pre><h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h3><pre><code>问题
   总线上连接着多个部件，什么时候由哪个部件发送信息
   如何防止信息丢失
   如何避免多个部件同时发送数据
   如何规定接收信息的部件
   这些问题是由总线控制器统一管理
基本概念
   主设备（ 主模块）：主设备对总线有控制权，总线上信息的传送是由主设备发启的
      例：CPU
    从设备（从模块）：只能响应主设备发来的信息，对总线没有控制权
       例：显示器
 总线判优控制（仲裁逻辑）
     链式查询
     计数器定时查询
     独立请求方式（排队）</code></pre><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><h3 id="思考几个问题"><a href="#思考几个问题" class="headerlink" title="思考几个问题"></a>思考几个问题</h3><pre><code>各部件共享总线，多个部件共同争用总线使用权，怎么办？优先级
通信时间上，怎么处理？分时
通信双方如何获知传输开始和传输结束，即从什么时候开始到什么时候结束
总线通信控制目标：通信双方如保相互配合、相互协调</code></pre><h3 id="总线传输周期：完成一次总线的操作时间"><a href="#总线传输周期：完成一次总线的操作时间" class="headerlink" title="总线传输周期：完成一次总线的操作时间"></a>总线传输周期：完成一次总线的操作时间</h3><pre><code>申请分配阶段：由主设备申请，总线控制器根据优先级决定下一周期哪个设备使用总线
寻址阶段：主设备向从设备发出地址、命令等等
传数阶段：主设备与从设备进行数据交换
结束阶段：主设备撤销有关信息，让出总线使用权</code></pre><h3 id="总线通信控制的四种方式"><a href="#总线通信控制的四种方式" class="headerlink" title="总线通信控制的四种方式"></a>总线通信控制的四种方式</h3><h4 id="同步：就是让接收知道发送方发送的数据是从什么时候开始到什么时候的技术"><a href="#同步：就是让接收知道发送方发送的数据是从什么时候开始到什么时候的技术" class="headerlink" title="同步：就是让接收知道发送方发送的数据是从什么时候开始到什么时候的技术"></a>同步：就是让接收知道发送方发送的数据是从什么时候开始到什么时候的技术</h4><pre><code>位同步：一个比特从什么时候开始到时候时候结束
外同步：有统一的时钟信号
自同步： 没有统一的时钟信号
      曼彻斯特编码
               同步：用在周期一半处的跳变代表同步
               跳变代表数据：从高到低的跳变表达数据0，从低到高的跳变表达数据1
       差分曼彻斯编码
               同步：用在周期一半处的跳变代表同步
               数据：周期开始处有跳变代表数据0，无跳变代表数据1
 字符同步：让接收方知识出数据块的开始和结束
    异步传输：以字符为单位进行数据传输，如果一个数据块由多个字符组成，传输字符与字符之间的时间间隔不固定，就叫异步传输
             注意： 在字符的前面加入一位起始位，用来表达字符的开始
                        在字符的后面加入一或两位终止位，用来表达字符的结束
                        在终止位的前面加入一位奇偶校验位
    同步传输：多个字符组成一个数据块进行传输，在数据块的开始和结尾分别加上用于同步控制的专用字
                        符，如SYN或0111110</code></pre><h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><pre><code>优点：规定明确、统一、模块间的配合简单一致
缺点：
    强制性“同步”，即必须在规定的时间内完成规定的要求
    时限限制，时限要以最慢的那个部件来设计</code></pre><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><pre><code>1义：没有统一的时钟标准，采用应答方式（又称为握手方式），即当主设备发出请求信号后，一直等
             从设备的应答信号，之后开始通信
异步通信的应答有三种类型
   不互锁
       主发请求，不等从应答信号，经过一段时间，确定从收到请求，主撤销请求信号
       从接到主请求，发应答信号，经过一段时间，确定主收到应答，自动撤销应答信号
   半互锁
        主发请求，等从的应答信号，再撤销请求信号，有互锁关系
        从收到请求，发应答信号，经过一段时间，自动撤销应答信号，没有互锁关系
    全互锁
         主发请求，等从的应答信号，再撤销请求信号，有互锁关系
         从发应答信号，等主撤销请求信号，再撤销应答信号，有互锁关系
  波特率：每秒钟传输数据比特的总位数，单位bps
                   注：在网络中，表达的是每秒钟可以传输多少个波形。
  比特率：每秒钟传输有效数据的比特位数，单位bps</code></pre><h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><h2 id="存储器基础知识"><a href="#存储器基础知识" class="headerlink" title="存储器基础知识"></a>存储器基础知识</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><pre><code>定义：计算机系统中具有记忆功能的部件，用来存放数据和程序的
存储器的地位越来越高
   CPU速度越来越快，而存储器读、写速度与CPU速配不匹配，从而使计算机的工作效率
   I/O设备与存储器进行交换信息要通信CPU，也会降低CPU工作的效率，解决办法DMA
   在多处理器系统中，需要共享存储器</code></pre><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><pre><code>按存储介质来分
   半导体存储器
   磁表面存储器
       例：磁带，磁盘，软盘
   磁芯存储器
   光盘存储器
 按存取方式来划分
    随机访问存存器（RAM）
        任何一个存储单元的内容都可随机读取
        存取时间与存储单元所在的物理位是没有关系
    只读存储器（ROM）:只能读取，而不能写
         可编程只读存储器（PROM)
         可擦除可编程只读存储器（EPROM)
         电可擦除可编程只读存储器（EEPROM）
     串行访问存储器（顺序存取存储器）
         例：磁带
     直接存取存储器：部分串行访问的存储器
         例：光盘，硬盘（里面由光盘组成的）
 按在计算机的作用来划分
 主存储器（内存）：可以与ＣＰＵ直接交换信息
     ＲＡＭ：静态ＲＡＭ(触发器)、动态RAM（电容充放电原理）
     ＲＯＭ
       辅助存储器：用来存放当前暂是不用的程序和数据，不能与CPU直接交换信息
           例：硬盘，光盘，优盘，移动硬盘
       缓冲存储器：用在两个速度不同的部件之间
          例：CPU与主存之间设置Cache,起到一个缓冲的作用
       闪速存存储器（flash memory</code></pre><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器的3个性能指标"><a href="#存储器的3个性能指标" class="headerlink" title="存储器的3个性能指标"></a>存储器的3个性能指标</h3><pre><code>速度：速度越高，位价越高
容量：容量越大，位价就越低，速度就越慢
位价</code></pre><h3 id="存储器的速度、容量、位价三者关系"><a href="#存储器的速度、容量、位价三者关系" class="headerlink" title="存储器的速度、容量、位价三者关系"></a>存储器的速度、容量、位价三者关系</h3><h3 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h3><pre><code>Cache----内存
内存-----辅存</code></pre><h3 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h3><pre><code>逻辑地址（虚拟地址）：程序员编程的地址范围
     例：机器指令地址码24位，则虚拟存储器存储单元的个数有16M个
物理地址：主存的实际地址
注：（1）当虚地址的内容在主存时，机器使可直接使用
       （2）当虚地址的内容不在主存时，则必须将虚地址的内容传递到主存的合适单元
                再为机器使用。</code></pre><h2 id="存储器校验—-汉明码-海明码"><a href="#存储器校验—-汉明码-海明码" class="headerlink" title="存储器校验—-汉明码(海明码)"></a>存储器校验—-汉明码(海明码)</h2><h3 id="错控制的概念"><a href="#错控制的概念" class="headerlink" title="错控制的概念"></a>错控制的概念</h3><h4 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h4><pre><code>@数据在传送的过程中产生了差错，即接收方接收的数据与发送方发送的数据不一致
@数据在存储过程中产生的差错</code></pre><h4 id="差错产生的原因：噪声"><a href="#差错产生的原因：噪声" class="headerlink" title="差错产生的原因：噪声"></a>差错产生的原因：噪声</h4><pre><code>@白噪声：外部电磁干扰引起的
@热噪声：设备或传输介质自身的原因引起</code></pre><h4 id="差错控制方法"><a href="#差错控制方法" class="headerlink" title="差错控制方法"></a>差错控制方法</h4><pre><code>@向前纠错：检查出差错后，直接纠正出错的比特
   例：海明码：检测出一位错误，并能纠正一位错误
@反馈重发：检查出差错后，通知发送方，再重传一次
    例：CRC</code></pre><h3 id="海明码基本概念"><a href="#海明码基本概念" class="headerlink" title="海明码基本概念"></a>海明码基本概念</h3><h4 id="码距（编码的最小距离）：在某种编码系统中，任意两组合法编码（码字）之间最小二进制位数的差异"><a href="#码距（编码的最小距离）：在某种编码系统中，任意两组合法编码（码字）之间最小二进制位数的差异" class="headerlink" title="码距（编码的最小距离）：在某种编码系统中，任意两组合法编码（码字）之间最小二进制位数的差异"></a>码距（编码的最小距离）：在某种编码系统中，任意两组合法编码（码字）之间最小二进制位数的差异</h4><pre><code>例：A  000
       B  011
       C  101
       D  110
       当某一个比特出现差错后，不会变成另外一个码字</code></pre><h4 id="纠错理论：L-1-D-C-其中D-gt-C"><a href="#纠错理论：L-1-D-C-其中D-gt-C" class="headerlink" title="纠错理论：L-1=D+C   其中D&gt;=C"></a>纠错理论：L-1=D+C   其中D&gt;=C</h4><pre><code>L：编码最小距离，即码距
D：能检测出错的比特数
C：能纠正出错的比特数
上例中：L-1=2-1=1=D+C
 所以D=1,C=0
 例：A  00000  
        B  00111
        C  11010
        D  11101
  L-1=3-1=2=D+C
  两种情况：
                 （1）D=2,C=0
                 （2）D=1,C=1</code></pre><h4 id="提高检错纠错能力的办法"><a href="#提高检错纠错能力的办法" class="headerlink" title="提高检错纠错能力的办法"></a>提高检错纠错能力的办法</h4><pre><code>增大L</code></pre><h4 id="冗余位（校验位）-需要增加冗余位k位"><a href="#冗余位（校验位）-需要增加冗余位k位" class="headerlink" title="冗余位（校验位）:需要增加冗余位k位"></a>冗余位（校验位）:需要增加冗余位k位</h4><pre><code>   n+k+1&lt;=2^k
n：称为数据的位数，表达有n种可能出错的情况
k：冗余位的个数，用来表达有k种错误
1：表达只有一种正确的情况</code></pre><h4 id="海明码中数据位与校验位的位置关系"><a href="#海明码中数据位与校验位的位置关系" class="headerlink" title="海明码中数据位与校验位的位置关系"></a>海明码中数据位与校验位的位置关系</h4><pre><code>例：数据：0101
      冗余位k=3      r2=2^2=4    r1=2^1=2   r0=2^0=1
      1     2     3     4    5     6    7  
      r0    r1    0    r2   1     0     1</code></pre><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><pre><code>相同为0
不相同为1
例：0异或1=1    1异或1=0    0异或0=0
特点：0 1  1  1   相异或结果是1，也就是奇数个1进行异或，结果就是1
          0  1  0  1  相异或结果是0，也就是偶数个1进行异或，结果就是0</code></pre><h4 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h4><pre><code>相同为1
不相同为0</code></pre><h3 id="海明码检错纠错过程"><a href="#海明码检错纠错过程" class="headerlink" title="海明码检错纠错过程"></a>海明码检错纠错过程</h3><h4 id="海明码产生的过程"><a href="#海明码产生的过程" class="headerlink" title="海明码产生的过程"></a>海明码产生的过程</h4><pre><code>例4.17
答：数据：  1101
       n=4,根据n+k+1&lt;=2^k,可得k=3   
       冗余位分别叫r2   r1   r0
       位置安排如下
       1    2    3    4   5   6   7
       r0   r1   1   r2  1    0   1
     ---------------------------
       0    0    0    1   1   1    1      第三组   r2  1  0  1   ;偶校验 可得r2=0
       0    1    1    0   0   1    1      第二组   r1  1  0  1   ;偶校验 可得r1=0
       1    0    1    0   1   0    1      第一组   r0  1  1  1   ;偶校验  可得r0=1

       可得海明码为：1010101</code></pre><h4 id="检错、纠错的过程"><a href="#检错、纠错的过程" class="headerlink" title="检错、纠错的过程"></a>检错、纠错的过程</h4><pre><code>例：假设传送的海明码为：1010101，接收方接收到的是：1010111，判断接收的数据是否出现了差错
       哪位出错了？
     答：位置安排如下
     1    2    3    4   5   6   7
     1    0    1    0   1   1   1
   ---------------------------
     0    0    0    1   1   1    1      第三组   s2=0  1  1  1   ；异或运算的结果s2=1
     0    1    1    0   0   1    1      第二组   s1=0  1  1  1   ;   异或运算的结果s1=1
     1    0    1    0   1   0    1      第一组   s0=1  1  1  1   ;   异或运算的结果s0=0

     s2s1s0=110,因为不为0，所以接收到的数据出现了差错，第6位出现了差错</code></pre><h2 id="高速缓冲存储器—-Cache"><a href="#高速缓冲存储器—-Cache" class="headerlink" title="高速缓冲存储器—-Cache"></a>高速缓冲存储器—-Cache</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>1.CPU空等现象，会降低CPU的工作效率，解决办法是在CPU与内存之间增加一级缓存
2.主存速度的提主始终跟不上CPU的发展
3.Cache的出现使CPU可以不直接访问内存，而与Cache直接交换信息（程序的局部性原理）
   例：子程序、循环
以上问题都希望通过Cache来解决主存与CPU的速度不匹配的问题</code></pre><h3 id="Cache的工作原理"><a href="#Cache的工作原理" class="headerlink" title="Cache的工作原理"></a>Cache的工作原理</h3><h4 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h4><pre><code>@字空间：存储单元的个数
    例：假设存储单元的地址用n位二进制数表达，则有多少个存储单元？
           答：2^n
 @分块
    （1）将主存和Cache进行分块，每块内包含若干个存储单元
    （2）块大小相同，块的大小也称为块长
      注：主存中的块数是多于Cache中的块数的
      例：主存空间为4KB，若分成四块，每个块号是什么？块长是多少？块内地址的范围是多少？
             答：块号：00  01   10  11 
                    块长：1024
                    块内地址：0-1023</code></pre><h4 id="CPU欲读主存某字时，怎么读？"><a href="#CPU欲读主存某字时，怎么读？" class="headerlink" title="CPU欲读主存某字时，怎么读？"></a>CPU欲读主存某字时，怎么读？</h4><pre><code>@所需要的字已经在Cache中，即直接访问（CPU与Cache之间一次传输一个字）
@所需要的字不在Cache中，此时就需要将字所在的主存中的对应块一次调入Cache中
    （主存与Cache之间一次传输一个块）
  注：如果主存中的块已经调入Cache中，我们就称主存与Cache建立了对应关系</code></pre><h4 id="命中率：指CPU要访问的信息已经在Cache内的比率"><a href="#命中率：指CPU要访问的信息已经在Cache内的比率" class="headerlink" title="命中率：指CPU要访问的信息已经在Cache内的比率"></a>命中率：指CPU要访问的信息已经在Cache内的比率</h4><pre><code>@命中率：h=Nc/(Nc+Nm)
@未命中率：1-h</code></pre><h4 id="平均访问时间-Cache—-主存系统之间的平均访问时间"><a href="#平均访问时间-Cache—-主存系统之间的平均访问时间" class="headerlink" title="平均访问时间(Cache—-主存系统之间的平均访问时间)"></a>平均访问时间(Cache—-主存系统之间的平均访问时间)</h4><pre><code>ta=h*tc+(1-h)*tm</code></pre><h4 id="访问效率：e-tc-ta-tc-htc-1-h-tm"><a href="#访问效率：e-tc-ta-tc-htc-1-h-tm" class="headerlink" title="访问效率：e=tc/ta=tc/[htc+(1-h)tm]"></a>访问效率：e=tc/ta=tc/[h<em>tc+(1-h)</em>tm]</h4><h3 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h3><pre><code>Cache存储体
地址映射机构
替换机构
Cache读写操作</code></pre><h2 id="Cache—主存地址映射"><a href="#Cache—主存地址映射" class="headerlink" title="Cache—主存地址映射"></a>Cache—主存地址映射</h2><h3 id="地址映射：由主存地址映射到Cache地址"><a href="#地址映射：由主存地址映射到Cache地址" class="headerlink" title="地址映射：由主存地址映射到Cache地址"></a>地址映射：由主存地址映射到Cache地址</h3><h3 id="地址映射方式"><a href="#地址映射方式" class="headerlink" title="地址映射方式"></a>地址映射方式</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>每个主存块只与一个缓存块相对应</p>
<pre><code>映射关系：i=j mod c  其中，i表达的是Cache的块号，j表在的是主存的块号
                                               c表达的是Cache中的块数
    例：设主存容量为256K字，Cache容量为2K字，块长为4，问
          （1）设计Cache地址格式，Cache中可以装入多少个块？
            答：高9位表达块号，低2位表达块内地址
                   可以装入512块
           （2）在直接映射方式下，设计主存地址格式
             答：标记   块号   块内地址
                     7        9位     2位
缺点：不灵活    
   某个主存块只能固定对应某个缓存块，即使缓存中还空着许多位置也不能占用
 如果要重复访问同一缓存位置的不同主存块，就要不停进行替换，从而降低命中率</code></pre><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p>允许主存中的每一块可以映射到缓存中的任何一个位置</p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p>某一主存块j按模Q映射至缓存的第i组中的任一块</p>
<pre><code>主存块j映射到第i组中（直接映射）：i=j mod Q 其中,j表达主存块号，Q表达Cache中
    有多少组，i表达组号
主存块j可以映射到第i组中的任何一个块中（全相联映射）</code></pre><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><pre><code>先进先出（FIFO）：实现办法---队列
近期最少使用（LRU)算法
随机法</code></pre><h2 id="辅助存储器-外存"><a href="#辅助存储器-外存" class="headerlink" title="辅助存储器(外存)"></a>辅助存储器(外存)</h2><h3 id="辅助存讲器概述"><a href="#辅助存讲器概述" class="headerlink" title="辅助存讲器概述"></a>辅助存讲器概述</h3><h4 id="特点（与内存相比"><a href="#特点（与内存相比" class="headerlink" title="特点（与内存相比)"></a>特点（与内存相比)</h4><pre><code>@ 容量大
@速度慢
@价格低
@可以脱机保存数据（属于非易失性的存储器）</code></pre><h4 id="辅助存储器的种类"><a href="#辅助存储器的种类" class="headerlink" title="辅助存储器的种类"></a>辅助存储器的种类</h4><pre><code>@硬磁盘
@软磁盘
@磁带
@光盘</code></pre><h4 id="磁表面存储器的结构"><a href="#磁表面存储器的结构" class="headerlink" title="磁表面存储器的结构"></a>磁表面存储器的结构</h4><pre><code>@磁道
@扇区
@扇段</code></pre><h3 id="磁表面存储器的技术指标"><a href="#磁表面存储器的技术指标" class="headerlink" title="磁表面存储器的技术指标"></a>磁表面存储器的技术指标</h3><h4 id="记录密度"><a href="#记录密度" class="headerlink" title="记录密度"></a>记录密度</h4><p>单位长度内所存储的二进制数信息量</p>
<pre><code>道密度：磁盘沿半径方向上单位长度内的磁道数  单位：tpi(磁道数每英寸)  或者tpm(磁道数每毫米）
道距：相邻两个磁道之间的距离  
    道密度与道距的关系：Dt=1/P
位密度：磁道上单位长度内所存储的二进制数信息量   单位：bpi 或bpm
    注意：（1）每个磁道上记录的信息总量是相同的
              （2）磁盘各磁道的位密度是不相同，一般泛指最内圈的位密码（最大位密度）</code></pre><h4 id="存储容量-1"><a href="#存储容量-1" class="headerlink" title="存储容量"></a>存储容量</h4><p>外存所能存储的二进制数信息量    单位： bit(位）    或    Byte(字节）</p>
<pre><code>  存储容量=n*k*s   其中n表达记录面个数   k表达磁道存储容量    s表达磁道个数
格式化的存储容量
非格式化的存储容量</code></pre><h4 id="平均寻址时间：Ta-Tsa-Twa"><a href="#平均寻址时间：Ta-Tsa-Twa" class="headerlink" title="平均寻址时间：Ta=Tsa+Twa"></a>平均寻址时间：Ta=Tsa+Twa</h4><pre><code>平均寻道时间：Tsa=(Tsmax+Tsmin)/2
平均等待时间：Twa=(Twmax+Twmin)/2</code></pre><h4 id="数据传输速率"><a href="#数据传输速率" class="headerlink" title="数据传输速率"></a>数据传输速率</h4><pre><code>单位时间内磁表面存储器向主机传送的数据信息量=位密度*速度</code></pre><h4 id="误码率：从辅存读出数据时，出错的信息量与读出的信息总量的比值"><a href="#误码率：从辅存读出数据时，出错的信息量与读出的信息总量的比值" class="headerlink" title="误码率：从辅存读出数据时，出错的信息量与读出的信息总量的比值"></a>误码率：从辅存读出数据时，出错的信息量与读出的信息总量的比值</h4><h2 id="硬磁盘存储器与CRC校验"><a href="#硬磁盘存储器与CRC校验" class="headerlink" title="硬磁盘存储器与CRC校验"></a>硬磁盘存储器与CRC校验</h2><h3 id="硬磁盘存储器的种类"><a href="#硬磁盘存储器的种类" class="headerlink" title="硬磁盘存储器的种类"></a>硬磁盘存储器的种类</h3><h4 id="按磁头的工作方式划分"><a href="#按磁头的工作方式划分" class="headerlink" title="按磁头的工作方式划分"></a>按磁头的工作方式划分</h4><pre><code>固定磁头的硬磁盘存储器：磁头位置固定不变，磁盘上每个磁道上都对应一个磁头
移动磁头的硬磁盘存储器：磁头在盘面上沿着半径方向运动</code></pre><h4 id="按磁是否具有可换性"><a href="#按磁是否具有可换性" class="headerlink" title="按磁是否具有可换性"></a>按磁是否具有可换性</h4><pre><code>可换盘的磁盘存储器
不可换盘的磁盘存储器</code></pre><h3 id="硬磁盘的磁道记录格式：数据在盘存上的记录要遵循一定的规律"><a href="#硬磁盘的磁道记录格式：数据在盘存上的记录要遵循一定的规律" class="headerlink" title="硬磁盘的磁道记录格式：数据在盘存上的记录要遵循一定的规律"></a>硬磁盘的磁道记录格式：数据在盘存上的记录要遵循一定的规律</h3><h4 id="定长记录格式"><a href="#定长记录格式" class="headerlink" title="定长记录格式"></a>定长记录格式</h4><pre><code>圆柱面（柱面）：n个记录面上同一半径的磁道组成的
    注：柱面号  与磁道号是相同的   磁道个数有几个，柱面就会有几个
柱面信息：柱面上磁道存储的信息
磁头号：盘面号
扇区
扇段：磁盘寻址的最小单位
     注：磁盘地址格式：  台号      磁道号 磁头号 扇段号
                                     台号      柱面号  盘面号 扇区</code></pre><h4 id="不定长记录可式"><a href="#不定长记录可式" class="headerlink" title="不定长记录可式"></a>不定长记录可式</h4><h3 id="循环冗余校验—-CRC校验"><a href="#循环冗余校验—-CRC校验" class="headerlink" title="循环冗余校验—-CRC校验"></a>循环冗余校验—-CRC校验</h3><h4 id="模2运算（特点：不考虑进位和借位）：异或运算"><a href="#模2运算（特点：不考虑进位和借位）：异或运算" class="headerlink" title="模2运算（特点：不考虑进位和借位）：异或运算"></a>模2运算（特点：不考虑进位和借位）：异或运算</h4><pre><code>模2加和模2减（异或）
    例：0+0=0   0+1=1   1+0=1   1+1=0
           0-0=0    0-1=1    1-0=1    1-1=0
    例：1100
        +0111
         --------
           1011
     例：1100
        -  0111
         -------
            1011
  模2乘
       例：1010
           *   101
           ---------
               1010
             0000
           1010
       --------------       注：偶数个1相异或结果是0   奇数个1相异或结果1
           100010
    模2除
       例：10000/101
              商=101     余数=1</code></pre><h4 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h4><h2 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="数据在计算机内部分都是由0和1组成的编码"><a href="#数据在计算机内部分都是由0和1组成的编码" class="headerlink" title="数据在计算机内部分都是由0和1组成的编码"></a>数据在计算机内部分都是由0和1组成的编码</h4><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>无符号数
有符号数
定点数
浮点数</code></pre><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><pre><code>算术运算
逻辑运算</code></pre><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><h4 id="计算机在读取的数据存放在寄存器中"><a href="#计算机在读取的数据存放在寄存器中" class="headerlink" title="计算机在读取的数据存放在寄存器中"></a>计算机在读取的数据存放在寄存器中</h4><h4 id="机器字长：寄存器的位数"><a href="#机器字长：寄存器的位数" class="headerlink" title="机器字长：寄存器的位数"></a>机器字长：寄存器的位数</h4><h4 id="无符号数：没有符号的数，即在寄存器中的每一位都是用来表达数值"><a href="#无符号数：没有符号的数，即在寄存器中的每一位都是用来表达数值" class="headerlink" title="无符号数：没有符号的数，即在寄存器中的每一位都是用来表达数值"></a>无符号数：没有符号的数，即在寄存器中的每一位都是用来表达数值</h4><pre><code>注：寄存器中要存放的是有符号数的话，则要留出一位用来表达符号
例：假设机器字长4位，无符数和有符号数表达数的范围大小是多少
       答：无符号数表达的范围是:0~2^4-1
              有符号数表达的范围是：-2^3~2^3-1</code></pre><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><h4 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h4><pre><code>正、负号的表达（符号数字化）
   正号用  0  表达
   负号用  1  表达
 有符号数：规定将0（正）和1（负）放在数字的前面
     例：有符号整数
            +1101       在机器中表达为    0  1101
             -1101       在机器中表达为    1  1101
     例：有符号小数
            +0.1101   在机器中表达为     0   1101  
            -0.1101    在机器中表达为     1   1101
  机器数：把符号“数字化”的数
  真值：把带“+”或“-”的数称为真值</code></pre><h4 id="原码表示法：就是机器数"><a href="#原码表示法：就是机器数" class="headerlink" title="原码表示法：就是机器数"></a>原码表示法：就是机器数</h4><pre><code>整数原码的定义
    [x]原=0 x       0&lt;=x&lt;2^n
    [x]原=2^n-x   -2^n&lt;x&lt;=0
            其中   x表达的是真值，n表达的是数据的位数
            例：当x=+1010   [x]原=0, 1010
                  当x=-1010     [x]原=2^4-x=10000-(-1010)=10000+1010=1, 1010
 小数原码的定义
     [x]原=x           0&lt;=x&lt;1
     [x]原=1-x        -1&lt;x&lt;=0
              其中   x表达的是真值
              例：当x=+0.1010     [x]原=0.1010
                    当x=-0.1010       [x]原=1-x=1-(-0.1010)=1+0.1010=1.1010
        例：当x=+011001     [x]原=0,011001
               当x=-0010110    [x]原=1,0010110
    特别注意+0和-0的原码
        [+0.0000]原=0.0000
        [-0.0000]原=1.0000
          结论是：原码中的“零”有两种表示形式</code></pre><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><h4 id="例：设机器数字长为8位（含1位符号位），求00-87-13-64-29-128的原码"><a href="#例：设机器数字长为8位（含1位符号位），求00-87-13-64-29-128的原码" class="headerlink" title="例：设机器数字长为8位（含1位符号位），求00     -87     -13/64     29/128的原码"></a>例：设机器数字长为8位（含1位符号位），求00     -87     -13/64     29/128的原码</h4><pre><code>[100]原=[+1100100]原=0，1100100
[-87]原=[-1010111]原=1,1010111
[-13/64]原=[-1101*2^(-6)]原
                =[-0.001101]原
                =1.0011010
[29/128]原=[+0.0011101]原=0.0011101</code></pre><h4 id="缺点：加减运算时比较麻烦"><a href="#缺点：加减运算时比较麻烦" class="headerlink" title="缺点：加减运算时比较麻烦"></a>缺点：加减运算时比较麻烦</h4><pre><code>要判断两个数的绝对值大小
用绝对值大的数减去绝对值小的数
结果的符号位与绝对值大的数的符号位相同</code></pre><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><h4 id="作用：将减法运算转换为加法运算"><a href="#作用：将减法运算转换为加法运算" class="headerlink" title="作用：将减法运算转换为加法运算"></a>作用：将减法运算转换为加法运算</h4><h4 id="补数的概念"><a href="#补数的概念" class="headerlink" title="补数的概念"></a>补数的概念</h4><pre><code>模
补数
例：时钟指示为6点，欲使它指向3点，怎么办？
例：设A=9,B=5,求A-B(MOD 12)
       答：A-B=9-5=4
             A-B=9-5=9+7=16-12=4</code></pre><h4 id="结论：求一个数的补数，就用这个数去除以模求余数，这个余数就是要求的补数"><a href="#结论：求一个数的补数，就用这个数去除以模求余数，这个余数就是要求的补数" class="headerlink" title="结论：求一个数的补数，就用这个数去除以模求余数，这个余数就是要求的补数"></a>结论：求一个数的补数，就用这个数去除以模求余数，这个余数就是要求的补数</h4><pre><code>一个负数可以用它的正补数代替
一个正数一个负补数绝对值相加，结果必定与模相同
正数的补数还是它自身</code></pre><h4 id="整数补数的定义"><a href="#整数补数的定义" class="headerlink" title="整数补数的定义"></a>整数补数的定义</h4><pre><code>[x]补=0,x               0&lt;=x&lt;2^n
[x]补=2^(n+1)+x           -2^n&lt;x&lt;=0
      其中，x是真值，n是整数的位数
      例：当x=+1010   [x]补=0，1010
            当x=-01101   [x]补=2^6+x=1000000-01101
                                                     =1,10011</code></pre><h4 id="小数补数的定义"><a href="#小数补数的定义" class="headerlink" title="小数补数的定义"></a>小数补数的定义</h4><pre><code>[x]补=x               0&lt;=x&lt;1
[x]补=2+x           -1&lt;x&lt;=0
    例：当x=+0.1010   [x]补=0.1010
           当x=-0.1010   [x]补=2-0.1010=1.0110</code></pre><h4 id="特别注意-0和-0的补码"><a href="#特别注意-0和-0的补码" class="headerlink" title="特别注意+0和-0的补码"></a>特别注意+0和-0的补码</h4><pre><code>[+0.0000]补=0.0000
[-0.0000]补=2-0.0000=10.0000-0.0000=10.0000=0.0000
 结论：被码中的“零”只有一种表示形式</code></pre><h4 id="特别注意-1的补码"><a href="#特别注意-1的补码" class="headerlink" title="特别注意-1的补码"></a>特别注意-1的补码</h4><pre><code>   若-1为整数，则[-1]补=1，1
   若-1为小数，则[-1.0000]补=2-1.0000=10.0000-1.0000=1.0000
总结：求x的补码过程为
         （1）如果x为正数，x的补码与原码相同
         （2）如果x为负数，x的补码为符号位不变，其它位取反加1</code></pre><h2 id="反码、移码"><a href="#反码、移码" class="headerlink" title="反码、移码"></a>反码、移码</h2><h3 id="问题：补码的作用是什么？"><a href="#问题：补码的作用是什么？" class="headerlink" title="问题：补码的作用是什么？"></a>问题：补码的作用是什么？</h3><pre><code>例：x=-1010   [x]补=2^5-1010
                   =100000-1010
                   =11111+1-1010
                   =11111-1010+1
                   =反码+1</code></pre><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><h4 id="作用：用来由原码求补码-或者由补码求原码的一个中间过渡"><a href="#作用：用来由原码求补码-或者由补码求原码的一个中间过渡" class="headerlink" title="作用：用来由原码求补码 或者由补码求原码的一个中间过渡"></a>作用：用来由原码求补码 或者由补码求原码的一个中间过渡</h4><h4 id="整数反码的定义"><a href="#整数反码的定义" class="headerlink" title="整数反码的定义"></a>整数反码的定义</h4><pre><code>@[x]反=0,x       0&lt;=x&lt;2^n
@[x]反=2^n+x     -2^n&lt;x&lt;=0
例：x=+11100    [x]原=[x]反=[x]补=0，11100 
    x=-11100    [x]原=1,11100 
                [x]反=1,00011
                [x]补=1,00100</code></pre><h4 id="小数反码的定义"><a href="#小数反码的定义" class="headerlink" title="小数反码的定义"></a>小数反码的定义</h4><pre><code>@[x]反=x                0&lt;=x&lt;1
@[x]反=[2-2^(-n)]+x     -1&lt;x&lt;=0
例:x=+0.11100   [x]原=0.11100  
                [x]反=0.11100
                [x]补=0.11100
   x=-0.11100   [x]原=1.11100
                [x]反=1.00011
                [x]补=1.00100</code></pre><h4 id="特别注意-0和-0的反码"><a href="#特别注意-0和-0的反码" class="headerlink" title="特别注意+0和-0的反码"></a>特别注意+0和-0的反码</h4><pre><code>@[+0.0000]反=0.0000
@[-0.0000]反=1.1111</code></pre><h3 id="大总结"><a href="#大总结" class="headerlink" title="大总结"></a>大总结</h3><h4 id="一个正数原码、反码、补码都是一样的"><a href="#一个正数原码、反码、补码都是一样的" class="headerlink" title="一个正数原码、反码、补码都是一样的"></a>一个正数原码、反码、补码都是一样的</h4><h4 id="一个负数的反码是原码的符号位不变，其它位取反"><a href="#一个负数的反码是原码的符号位不变，其它位取反" class="headerlink" title="一个负数的反码是原码的符号位不变，其它位取反"></a>一个负数的反码是原码的符号位不变，其它位取反</h4><h4 id="一个负数的补码是反码的最低位加上1得到的"><a href="#一个负数的补码是反码的最低位加上1得到的" class="headerlink" title="一个负数的补码是反码的最低位加上1得到的"></a>一个负数的补码是反码的最低位加上1得到的</h4><pre><code>例：设机器数字长是8位（其中有一位是符号位），对于整数
    ，其中分别表示的无符号数，原码，反码，补码，对应的真值分别是什么。</code></pre><h3 id="移码：经常用在阶码中"><a href="#移码：经常用在阶码中" class="headerlink" title="移码：经常用在阶码中"></a>移码：经常用在阶码中</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><pre><code>当x=+7=+0111    [x]补=0，0111
当x=-7=-0111    [x]补=1，1001</code></pre><h4 id="移码：就是将补码的符号位取反得到的"><a href="#移码：就是将补码的符号位取反得到的" class="headerlink" title="移码：就是将补码的符号位取反得到的"></a>移码：就是将补码的符号位取反得到的</h4><pre><code>当x=+7=+0111    [x]补=0，0111   [x]移=1，0111
当x=-7=-0111    [x]补=1，1001   [x]移=0，1001</code></pre><h2 id="数的定点表示和浮点表示（定点数和浮点数）"><a href="#数的定点表示和浮点表示（定点数和浮点数）" class="headerlink" title="数的定点表示和浮点表示（定点数和浮点数）"></a>数的定点表示和浮点表示（定点数和浮点数）</h2><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><h4 id="定义：小数点的位置固定不变的数"><a href="#定义：小数点的位置固定不变的数" class="headerlink" title="定义：小数点的位置固定不变的数"></a>定义：小数点的位置固定不变的数</h4><pre><code>数符
数值</code></pre><h4 id="定点数的分类"><a href="#定点数的分类" class="headerlink" title="定点数的分类"></a>定点数的分类</h4><pre><code>定点整数（纯整数）：小数点约定在数值之后
定点小数（纯小数）：小数点约定在数符之后</code></pre><h4 id="数的表示范围（假设数值部分的位数为n位，且用原码表达）"><a href="#数的表示范围（假设数值部分的位数为n位，且用原码表达）" class="headerlink" title="数的表示范围（假设数值部分的位数为n位，且用原码表达）"></a>数的表示范围（假设数值部分的位数为n位，且用原码表达）</h4><pre><code>定点整数的表达范围：-（2^-1)~+（2^n-1)
定点小数的表达范围：-（1-2^(-n))~+(1-2^(-n))</code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre><code>有些数据是不能用纯整数或纯小数表达的
   例：圆周率=3.1415
             =31415*10^(-4)
             =0.0031415*10^3
             =0.31415*10^1
数值的范围很大或很小
   例：电子质量9*10^(-28)g</code></pre><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="定义：小数点的位置可以发生变化（浮动）的数"><a href="#定义：小数点的位置可以发生变化（浮动）的数" class="headerlink" title="定义：小数点的位置可以发生变化（浮动）的数"></a>定义：小数点的位置可以发生变化（浮动）的数</h4><h4 id="浮点的表示方式"><a href="#浮点的表示方式" class="headerlink" title="浮点的表示方式"></a>浮点的表示方式</h4><pre><code>N=S*r^j

S称为尾数  可正可负
j称为阶码  可正可负
r称为基数  r=2   8    10    16
   例：N=111.0101
        =1110101*2^(-4)
        =0.0001110101*2^6
        =0.1110101*2^3</code></pre><h4 id="浮点数在计算机中的规定（规格化的数）"><a href="#浮点数在计算机中的规定（规格化的数）" class="headerlink" title="浮点数在计算机中的规定（规格化的数）"></a>浮点数在计算机中的规定（规格化的数）</h4><pre><code>尾数用定点小数表达
尾数数值部分的最高位要为1
 左规
      例：0.000000001010
          =0.1010*2^(-8)
 右规
      例：1010111.101
          =0.1010111101*2^7</code></pre><h4 id="浮点数在计算机中存储形式"><a href="#浮点数在计算机中存储形式" class="headerlink" title="浮点数在计算机中存储形式"></a>浮点数在计算机中存储形式</h4><pre><code>阶符 阶码  数符 数值
阶码为整数  用来表达数据的范围及小数点的位置
尾数用定点小数表达 用来表示数据的精度</code></pre><h3 id="浮点数的表达范围"><a href="#浮点数的表达范围" class="headerlink" title="浮点数的表达范围"></a>浮点数的表达范围</h3><pre><code>假设尾数数值为n位，阶码数值为m位 而且都用原码表达
最大的正数
最小的正数
最大的负数
最小的负数</code></pre><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="移位运算-1"><a href="#移位运算-1" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="例：15m-1500cm"><a href="#例：15m-1500cm" class="headerlink" title="例：15m=1500cm"></a>例：15m=1500cm</h4><h4 id="意义：相当于让某一个数乘以或者除以r-n"><a href="#意义：相当于让某一个数乘以或者除以r-n" class="headerlink" title="意义：相当于让某一个数乘以或者除以r^n"></a>意义：相当于让某一个数乘以或者除以r^n</h4><pre><code>@r称为基数
@n为向左或向右移动的位数</code></pre><h4 id="价值：计算机可以使用移位、加、减运算实现乘除运算"><a href="#价值：计算机可以使用移位、加、减运算实现乘除运算" class="headerlink" title="价值：计算机可以使用移位、加、减运算实现乘除运算"></a>价值：计算机可以使用移位、加、减运算实现乘除运算</h4><h4 id="问题：移出的空位用0还是用1补齐呢？"><a href="#问题：移出的空位用0还是用1补齐呢？" class="headerlink" title="问题：移出的空位用0还是用1补齐呢？"></a>问题：移出的空位用0还是用1补齐呢？</h4><h3 id="算术移位（有符号数的移位）"><a href="#算术移位（有符号数的移位）" class="headerlink" title="算术移位（有符号数的移位）"></a>算术移位（有符号数的移位）</h3><h4 id="正数的移位规则"><a href="#正数的移位规则" class="headerlink" title="正数的移位规则"></a>正数的移位规则</h4><pre><code>因为[x]原=[x]反=[x]补=真值，移出的空位用0补齐
例：x=+0010100   
    [x]原=[x]反=[x]补=0，0010100   +20
             左移一位=0，0101000   +40
             左移两位=0，1010000   +80
             左移三位=0，0100000   +32   注：如果移出的是1，结果出错

             右移一位=0，0001010   +10
             右移两位=0，0000101   +5
             右移三位=0，0000010   +2   注：如果移出的是1，结果出错</code></pre><h4 id="负数的移位规则"><a href="#负数的移位规则" class="headerlink" title="负数的移位规则"></a>负数的移位规则</h4><pre><code>原码的移位：空位用0补齐
  例：x=-0010100
         [x]原=1，0010100   -20
      左移一位=1，0101000   -40
      左移两位=1，1010000   -80
      左移三位=1，0100000   -32      注：如果移出的是1，结果出错

      右移一位=1，0001010   -10
      右移两位=1，0000101   -5
      右移三位=1，0000010   -2      注：如果移出的是1，结果出错

 反码的移位：移出的空位用1补齐
  例：x=-0010100
         [x]反=1，1101011
      左移一位=1，1010111
      左移两位=1，0101111
      左移三位=1，1011111   注：如果移出的是0，结果出错

      右移一位=1，1110101
      右移两位=1，1111010
      右移三位=1，1111101   注：如果移出的是0，结果出错 
  补码的移位：左移移出的空位用0补齐，右移移出的空位用1补齐
    例：x=-0010100
          [x]补=1，1101100
       左移一位=1，1011000
       左移两位=1，0110000
       左移三位=1，1100000   注：如果移出的是0，结果出错

       右移一位=1，1110110
       右移两位=1，1111011
       右移三位=1，1111101   注：如果移出的是1，结果出错
 注意：有符号的移位，符号位不变，这是有符号移位的特点</code></pre><h3 id="逻辑移位（无符号数的移位）"><a href="#逻辑移位（无符号数的移位）" class="headerlink" title="逻辑移位（无符号数的移位）"></a>逻辑移位（无符号数的移位）</h3><h4 id="逻辑左移"><a href="#逻辑左移" class="headerlink" title="逻辑左移"></a>逻辑左移</h4><pre><code>例：机器字长为8位，存储的内容为 10101011
    逻辑左移一位=01010110
    算术左移一位=11010110</code></pre><h4 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h4><pre><code>例：机器字长为8位，存储的内容为 10101011
    逻辑右移一位=01010101
    算术左移一位=11010101</code></pre><h2 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h2><h3 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h3><pre><code>A+B]补=[A]补+[B]补
[A-B]补=[A+(-B)]补=[A]补+[-B]补</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>符号位与数值位同样参与运算
高位的进位自然丢弃
[-B]补码等于[B]补各位（包括符号位）取反加1 </code></pre><h2 id="补码加减溢出的判断"><a href="#补码加减溢出的判断" class="headerlink" title="补码加减溢出的判断"></a>补码加减溢出的判断</h2><h3 id="补码加减基本公式"><a href="#补码加减基本公式" class="headerlink" title="补码加减基本公式"></a>补码加减基本公式</h3><pre><code>[A+B]补=[A]补+[B]补
[A-B]补=[A+(-B)]补=[A]补+[-B]补</code></pre><h3 id="补码加减溢出的判断方法"><a href="#补码加减溢出的判断方法" class="headerlink" title="补码加减溢出的判断方法"></a>补码加减溢出的判断方法</h3><h4 id="用一位符号位进行判断：结果的符号位与两个操作数的符号不相同，则结果出错了（溢出）"><a href="#用一位符号位进行判断：结果的符号位与两个操作数的符号不相同，则结果出错了（溢出）" class="headerlink" title="用一位符号位进行判断：结果的符号位与两个操作数的符号不相同，则结果出错了（溢出）"></a>用一位符号位进行判断：结果的符号位与两个操作数的符号不相同，则结果出错了（溢出）</h4><pre><code>例：假设字长4位（包括一位符号位）
A=5  B=4  求[A+B]补
  答：A=+5=+101   [A]原=0，101  [A]补=0，101
      B=+4=+100   [B]原=0，100  [B]补=0，100
      [A+B]补=[A]补+[B]补
              0，101
              0，100
            ---------
              1，001              0异或1=1  结果出错
       [A+B]补=1，001   
       [A+B]原=1，111   A+B=-111 即-7   

A=-5  B=-4  求[A+B]补
 答：A=-5=-101   [A]原=1，101  [A]补=1，011
     B=-4=-100   [B]原=1，100  [B]补=1，100
     [A+B]补=[A]补+[B]补
             1，011
           + 1，100
           ---------
            10，111   1异或0=1  结果出错
      [A+B]补=0，111 
      [A+B]原=0，111   A+B=+111 即+7 

 A=5  B=2  求[A+B]补
  答：0，101
      0，010
     -------
      0，111     0异或0=0   结果正确
    注：计算机判断溢出的方法是：最高的进位与数值部分的最高位的进位进行异或  </code></pre><h4 id="双符位判断溢出（变形补码）：如果结果的双符号位不相同，则结出出错"><a href="#双符位判断溢出（变形补码）：如果结果的双符号位不相同，则结出出错" class="headerlink" title="双符位判断溢出（变形补码）：如果结果的双符号位不相同，则结出出错"></a>双符位判断溢出（变形补码）：如果结果的双符号位不相同，则结出出错</h4><h2 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h2><h3 id="分析笔算乘法"><a href="#分析笔算乘法" class="headerlink" title="分析笔算乘法"></a>分析笔算乘法</h3><pre><code>例：A=0.1101   B=0.1011  求A*B</code></pre><h4 id="乘积的符号位是由两个乘数的符号位进行“异或”得到的"><a href="#乘积的符号位是由两个乘数的符号位进行“异或”得到的" class="headerlink" title="乘积的符号位是由两个乘数的符号位进行“异或”得到的"></a>乘积的符号位是由两个乘数的符号位进行“异或”得到的</h4><h4 id="乘积的数值部分计算如下"><a href="#乘积的数值部分计算如下" class="headerlink" title="乘积的数值部分计算如下"></a>乘积的数值部分计算如下</h4><pre><code>   0.1101
  *0.1011
  --------
     1101-------A*2^0
    1101        A*2^1
   0000         0*2^2
  1101          A*2^3
 --------
0.10001111
   注意：手算的过程包含了：移位运算和4个部分积相加</code></pre><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><pre><code>将4个部分积进行相加，计算机很难实现
乘积的位数增加一倍</code></pre><h3 id="笔算乘法的改进"><a href="#笔算乘法的改进" class="headerlink" title="笔算乘法的改进"></a>笔算乘法的改进</h3><pre><code>例：A=0.1101   B=0.1011  求A*B
  注：ACC寄存放存放乘积高位     MQ寄存器存放乘数及乘积低位   X寄存器存放被乘数
    A*B=A*0.1011
       =A*(0.1+0.00+0.001+0.0001)
       =0.1A+0.00A+0.001A+0.0001A
       =0.1A+0.00A+0.001(A+0.1(A+0))
       =0.1A+0.01[0A+0.1(A+0.1(A+0))]
       =0.1{A+0.1[0A+0.1(A+0.1(A+0))]}
 计算机的执行过程：
     部分积（ACC)    乘数(MQ)
     0.0000          1011
    +0.1101
    -------
     0.1101---&gt;1
     0.0110          1 101
     0.1101
    --------
     1.0011---&gt;1
     0.1001          11 10
     0.0000
    ------------
     0.1001---&gt;1
     0.0100          111 1
     0.1101
    --------
     1.0001---&gt;1
     0.1000          1111</code></pre><h3 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h3><pre><code>例：A=-0.1110  B=-0.1101  求[A*B]原
答：[A]原=1.1110    [B]原=1.1101
    乘积的符号位=1 异或  1=0
    部分积    乘数
    0.0000    1101
    0.1110
   -------
    0.1110---&gt;1
    0.0111    0 110
    0.0000
   --------
    0.0111----&gt;1
    0.0011    10 11
    0.1110
   --------
    1.0001---&gt;1
    0.1000    110 1
    0.1110
  ---------
    1.0110---&gt;1                  注：这里的移位是逻辑移位
    0.1011     0110 

    [A*B]原=0.1011 0110</code></pre><h3 id="原码两位乘法"><a href="#原码两位乘法" class="headerlink" title="原码两位乘法"></a>原码两位乘法</h3><pre><code>乘数两位的状态
00：原部分积+A*0  --&gt;2       
01:原部分积+A   ----&gt;2
10:原部分积+2A  ----&gt;2
11:原部分积+3A</code></pre><h2 id="原码除法运算"><a href="#原码除法运算" class="headerlink" title="原码除法运算"></a>原码除法运算</h2><h3 id="分析除法笔算过程"><a href="#分析除法笔算过程" class="headerlink" title="分析除法笔算过程"></a>分析除法笔算过程</h3><pre><code>例：x=-0.1011   y=0.1101  求x/y</code></pre><h4 id="商的符号位等于两个操作数的符号位进行异或得到的"><a href="#商的符号位等于两个操作数的符号位进行异或得到的" class="headerlink" title="商的符号位等于两个操作数的符号位进行异或得到的"></a>商的符号位等于两个操作数的符号位进行异或得到的</h4><h4 id="数值部分的运算过程"><a href="#数值部分的运算过程" class="headerlink" title="数值部分的运算过程"></a>数值部分的运算过程</h4><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><pre><code>机器不能心算上商    机器上商是试出来的
商是从高位向低位逐步求的
加法器的位数必须是除数的两倍</code></pre><h4 id="原码除法必须满足的两个条件"><a href="#原码除法必须满足的两个条件" class="headerlink" title="原码除法必须满足的两个条件"></a>原码除法必须满足的两个条件</h4><pre><code>被除数和除数不能为0
 0&lt;|被除数|&lt;|除数|</code></pre><h3 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><pre><code>例：x=-0.1011  y=-0.l101  求x/y
答:[x]原=1.1011   [y]原=1.1101
   |x|=0.1011     |y|=0.1101
                  [|y|]补=0.1101
                  [-|y|]补=1.0011
   商的符号=1 异或1 =0

   余数（被除数）     商
   0.1011 
  +1.0011  
  --------
   1.1110             0
  +0.1101
  --------
 1 0.1011     &lt;----1
   1.0110
 + 1.0011
  --------
 1 0.1001             01   &lt;----1
   1.0010
 + 1.0011
 ---------
 1 0.0101             011   &lt;---1
   0.1010
 + 1.0011
  --------
   1.1101             0110
 + 0.1101
  -------
 1 0.1010   &lt;---1
   1.0100
 + 1.0011
 --------
 1 0.0111            01101

 x/y=+0.1101-----0.00000111</code></pre><h4 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h4><pre><code>@R&gt;0    上商1   2R-Y
@R&lt;0    上商0   2R+Y

例：x=-0.1011  y=-0.l101  求x/y
答:[x]原=1.1011   [y]原=1.1101
   |x|=0.1011     |y|=0.1101
                  [|y|]补=0.1101
                  [-|y|]补=1.0011
   商的符号=1 异或1 =0

   余数（被除数）     商
   0.1011  
  +1.0011
  -------
   1.1110          0 &lt;----1
   1.1100
 + 0.1101
 ---------
 1 0.1001          01&lt;----1
   1.0010
  +1.0011
  --------
 1 0.0101          011&lt;----1
   0.1010
 + 1.0011
  --------
   1.1101          0110 &lt;---1
   1.1010
 + 0.1101
----------
 1 0.0111          01101

 x/y=+0.1101--------0.00000111</code></pre><h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><h3 id="浮点数的书写格式"><a href="#浮点数的书写格式" class="headerlink" title="浮点数的书写格式"></a>浮点数的书写格式</h3><pre><code>x=s*r^j</code></pre><h4 id="s称为尾数，尾数一般用原码或者补码表达，而且用规格化的数表达"><a href="#s称为尾数，尾数一般用原码或者补码表达，而且用规格化的数表达" class="headerlink" title="s称为尾数，尾数一般用原码或者补码表达，而且用规格化的数表达"></a>s称为尾数，尾数一般用原码或者补码表达，而且用规格化的数表达</h4><pre><code>@左规
  例：0.000010101*2^7
     =0.10101*2^3
@右规
  例：11010.11001*2^3
    = 0.1101011001*2^8</code></pre><h4 id="j称为阶码，阶码一般用补码或移码表达，而且只能是整数"><a href="#j称为阶码，阶码一般用补码或移码表达，而且只能是整数" class="headerlink" title="j称为阶码，阶码一般用补码或移码表达，而且只能是整数"></a>j称为阶码，阶码一般用补码或移码表达，而且只能是整数</h4><h4 id="r称为基数"><a href="#r称为基数" class="headerlink" title="r称为基数"></a>r称为基数</h4><h3 id="浮点数在机器中存放格式"><a href="#浮点数在机器中存放格式" class="headerlink" title="浮点数在机器中存放格式"></a>浮点数在机器中存放格式</h3><pre><code>阶码  尾数</code></pre><h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><h4 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h4><h4 id="尾数相加减"><a href="#尾数相加减" class="headerlink" title="尾数相加减"></a>尾数相加减</h4><h4 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h4><h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><pre><code>  0舍1入法
  恒置1法

例：x=0.1101*2^01   y=(-0.1010)*2^11,x+y
   假设 阶码4位，尾数6位，各包含一位符号位
答：[x]补=0，001；0.11010
    [y]补=0，011；1.01100</code></pre><h5 id="对阶-1"><a href="#对阶-1" class="headerlink" title="对阶"></a>对阶</h5><pre><code>阶差=0，001-0，011=0，001+（-0，011）补
    =0，001
   + 1，101
   ---------
     1，110     它的原码=1,010  即-2

[x]补=0，011；0，00110      10</code></pre><h5 id="尾数相加"><a href="#尾数相加" class="headerlink" title="尾数相加"></a>尾数相加</h5><pre><code> [x]补=0，011；0，00110 
 [y]补=0，011；1，01100
+-------------------------
       0，011；1，10010
所以[x+y]补=[x]补+[y]补=0，011；1，10010</code></pre><h5 id="规格化-1"><a href="#规格化-1" class="headerlink" title="规格化"></a>规格化</h5><pre><code>[x+y]补=0，010；1，00100   
[x+y]原=0，010；1，11100</code></pre><h5 id="舍入（假设保留四位小数）"><a href="#舍入（假设保留四位小数）" class="headerlink" title="舍入（假设保留四位小数）"></a>舍入（假设保留四位小数）</h5><pre><code>@0舍1入法
  [x+y]原=0，010；1，1110       
@恒置1法
  [x+y]原=0，010；1，1111   </code></pre>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/">课程复习</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/13/%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/">
                        <span class="hidden-mobile">单链表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "计算机组成原理&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
